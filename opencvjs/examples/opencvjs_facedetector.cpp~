#include <cv/base/io.h>
#include <cv/base/utils.h>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/objdetect/objdetect.hpp>

#include <iostream>

using namespace cv::base;



int main(int argc, const char** argv)
{
  cv::CascadeClassifier classifier;
  std::string cascade_file("data/haarcascade_frontalface_alt2.xml");
  if (!classifier.load(cascade_file)) {
    std::cerr << "Error loading face classifier" << std::endl;
    return 1;
  }

  std::cerr << "Successfully opened classifier" << std::endl;
  return 0;
}



#include <cstring>
#include <iostream>

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/objdetect/objdetect.hpp>

#include <emscripten/bind.h>

static void drawCircle(cv::Mat* image) {
  cv::circle(*image, cv::Point(100, 100), 50, cv::Scalar(244, 0, 0, 255));
}

class FaceDetector {
  cv::CascadeClassifier m_detector;

public:
  FaceDetector()
  {}

  bool configure(const std::string& path) {
    std::string cascade_file(path);
    if (!classifier.load(cascade_file)) {
      std::cerr << "Error loading face classifier" << std::endl;
      return false;
    }
    std::cerr << "Successfully opened classifier" << std::endl;
    return true;
  }

  bool detect(uintptr_t dst, int w, int h) {
    char* ptr = reinterpret_cast<char*>(dst);
    cv::Mat image(h, w, CV_8UC4);
    image.data = (unsigned char*)ptr;

    std::vector<Rect> faces;
    cv::Mat frame_gray;

    cv::cvtColor( image, frame_gray, CV_BGR2GRAY );
    cv::equalizeHist( frame_gray, frame_gray );

    m_detector.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30) );

    for( size_t i = 0; i < faces.size(); i++ )
  {
    Point center( faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5 );
    ellipse( frame, center, Size( faces[i].width*0.5, faces[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );

    Mat faceROI = frame_gray( faces[i] );
    std::vector<Rect> eyes;

    //-- In each face, detect eyes
    eyes_cascade.detectMultiScale( faceROI, eyes, 1.1, 2, 0 |CV_HAAR_SCALE_IMAGE, Size(30, 30) );

    for( size_t j = 0; j < eyes.size(); j++ )
     {
       Point center( faces[i].x + eyes[j].x + eyes[j].width*0.5, faces[i].y + eyes[j].y + eyes[j].height*0.5 );
       int radius = cvRound( (eyes[j].width + eyes[j].height)*0.25 );
       circle( frame, center, radius, Scalar( 255, 0, 0 ), 4, 8, 0 );
     }
  }

    return true;
  }

};

// Binding code
EMSCRIPTEN_BINDINGS(jstracker_example) {
  emscripten::class_<FaceDetector>("FaceDetector")
    .constructor()
    .function("configure", &FaceDetector::configure)
    .function("detect", &FaceDetector::detect, emscripten::allow_raw_pointers())
    ;
}
